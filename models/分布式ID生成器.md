# 分布式ID生成器

特点如下：
- 全局唯一性：不能出现有重复的ID标识，这是基本要求。
- 递增性：确保生成的ID对于用户或者业务都是递增的
- 高可用性：确保任何时候都能生成正确的ID
- 高性能性：在高并发的环境下依然表现良好

不仅仅是用户ID，实际互联网中有很多场景需要能够生成类似Mysql自增ID这样不断增大，同时又不会重复的id，以支持业务中的高并发场景

有一些比较典型的场景：
- 电商促销短时间内会有大量的订单涌入到系统中，比如每秒10w+
- 明星出轨时微博短时间内会产生大量的相关微博转发和评论的消息

这些场景下将数据插入数据库之前，我们需要给这些订单和消息先分配一个唯一的ID，然后再保存到数据库中。对这个id的要求是希望其中能带有一些时间信息，这样即使后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进行排序。


## snowflake
目前比较流行的是Twitter公司开源的雪花算法，snowflake算法，由64位整数组成分布式ID、性能较高，并且在单机上递增

snowflake-64bit 分布如下：
1bit-保留        41bits-时间戳         10bits-工作机器ID        12bits-序列号

1. 第一位始终是0，没有实际的作用
2. 时间戳：占用41bits，单位是毫秒，总共可以容纳约69年的时间，这里的时间戳不是相对2020-07-01，而是我们自己设定时间，例如自己的系统上线时间是2020-07-01，那么这个timestamp就可以是相对于这个时间的偏移量
3. 工作机器id：占用10bits，高5位是数据中心的ID，低位5位是工作节点ID，最多可以容纳1024个节点
4. 序列号：用来记录同毫秒内产生的不同ID，每个节点每毫秒从0开始不断累加，最多可以累加到4095，同一毫秒一共可以产生4096个ID。

所以snowflake算法在同一毫秒内最多可以生成 4096 * 1024 = 4194304个


## snowflake的golang实现
1. github.com/bwmarrin/snowflake 
是一个相当轻量化的snowflake的go实现，数据格式就是按照上面的数据格式来的；
支持动态调整位数，例如工作机器ID占用10位，可以自己定义数据中心ID和工作节点ID

2. github.com/sony/sonyflake
索尼公司的开源项目，基本思路和上面的差不多，但是在位分配上稍有不同
1bit-unused      39bits-timestamp      8bits-sequenceID      16bitis-machine ID 

它的想法是时间只用了39bits，但是时间单位变成了10ms，所以理论上支持176年，看来索尼对自己还是比较自信的。

索尼的这个包先省略


